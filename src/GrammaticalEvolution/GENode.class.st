Class {
	#name : #GENode,
	#superclass : #Object,
	#instVars : [
		'id',
		'value',
		'type',
		'nodeChildren',
		'depth',
		'fitness',
		'parents',
		'children',
		'position',
		'codon',
		'generation'
	],
	#category : #'GrammaticalEvolution-AST'
}

{ #category : #adding }
GENode >> addChild: aNode [

	self assert: aNode notNil.
	children add: aNode
]

{ #category : #adding }
GENode >> addParent: aNode [

	parents add: aNode.
	aNode addChild: self
]

{ #category : #accessing }
GENode >> allParents [

	| col |
	col := OrderedCollection new.
	self allParents: self on: col using: Set new.
	^ col
]

{ #category : #accessing }
GENode >> allParents: node on: collection using: set [

	node parents
		reject: [ :obj | set includes: obj generation -> obj position ]
		thenDo: [ :obj | 
			set add: obj generation -> obj position.
			collection add: obj.
			self allParents: obj on: collection using: set ]
]

{ #category : #accessing }
GENode >> children [
	^ children
]

{ #category : #accessing }
GENode >> codon [
	^ codon
]

{ #category : #accessing }
GENode >> codon: array [
	codon := array
]

{ #category : #copying }
GENode >> deepCopy [

	^ self class new
		  id: id;
		  type: type;
		  value: value;
		  nodeChildren: (nodeChildren collect: #deepCopy);
		codon: codon copy
]

{ #category : #accessing }
GENode >> depth [

	^ depth
]

{ #category : #accessing }
GENode >> depth: anObject [

	depth := anObject
]

{ #category : #comparing }
GENode >> equal: another [

	^ self class = another class and: [ 
		  id == another id and: [ 
			  type == another type and: [ 
				  self value = another value and: [ 
					  nodeChildren = another nodeChildren  ] ] ] ]
]

{ #category : #'public access' }
GENode >> evaluate [
	^ self pharoAST evaluate
]

{ #category : #accessing }
GENode >> fitness [

	^ fitness
]

{ #category : #accessing }
GENode >> fitness: anObject [

	fitness := anObject
]

{ #category : #accessing }
GENode >> generation [
	^ generation
]

{ #category : #accessing }
GENode >> generation: number [
	generation := number
]

{ #category : #accessing }
GENode >> id [

	^ id
]

{ #category : #accessing }
GENode >> id: anObject [

	id := anObject
]

{ #category : #initialization }
GENode >> initialize [

	nodeChildren := OrderedCollection new.
	depth := 0.
	parents := OrderedCollection new.
	children := OrderedCollection new.
	position := 0
]

{ #category : #testing }
GENode >> isCollectionNode [
	^ false
]

{ #category : #testing }
GENode >> isNonTerminalNode [

	^ false
]

{ #category : #testing }
GENode >> isTerminalSelectorNode [

	^ false
]

{ #category : #testing }
GENode >> isTerminalValueNode [

	^ false
]

{ #category : #accessing }
GENode >> nodeChildren [
	^ nodeChildren
]

{ #category : #accessing }
GENode >> nodeChildren: anObject [

	nodeChildren := anObject
]

{ #category : #accessing }
GENode >> parents [ 
	^ parents
]

{ #category : #conversion }
GENode >> pharoAST [

	^ self pharoAST: GEDecoderVisitor new
]

{ #category : #conversion }
GENode >> pharoAST: visitor [

	| instance |
	type ifNil: [ ^ value ].
	visitor addNode: self.
	instance := type new.
	instance acceptVisitor: visitor.
	^ visitor value
]

{ #category : #'public access' }
GENode >> pharoCode [

	^ self pharoAST formattedCode
]

{ #category : #accessing }
GENode >> position [
	^ position
]

{ #category : #accessing }
GENode >> position: number [
	position := number
]

{ #category : #printing }
GENode >> printOn: aStream [
	self subclassResponsibility 
]

{ #category : #accessing }
GENode >> type [

	^ type
]

{ #category : #accessing }
GENode >> type: anObject [

	type := anObject
]

{ #category : #accessing }
GENode >> value [ 
	^ value
]

{ #category : #accessing }
GENode >> value: anObject [

	value := anObject
]

{ #category : #'as yet unclassified' }
GENode >> withAllChildren [

	| c |
	c := OrderedCollection new.
	c add: self.
	self withAllChildren: c.
	^ c
]

{ #category : #'as yet unclassified' }
GENode >> withAllChildren: collection [

	"Private usage"

	nodeChildren do: [ :c | 
		collection add: c.
		c withAllChildren: collection ]
]
